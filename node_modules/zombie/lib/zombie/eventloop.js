var EventLoop, URL;
var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };
URL = require("url");
EventLoop = (function() {
  function EventLoop(window) {
    var lastHandle, processing, timers, waiting, wakeUp;
    timers = {};
    lastHandle = 0;
    window.setTimeout = function(fn, delay) {
      var handle, timer;
      timer = {
        when: window.browser.clock + delay,
        timeout: true,
        fire: __bind(function() {
          var evt;
          window.browser.log("Firing timeout " + handle + ", delay: " + delay);
          try {
            return window._evaluate(fn);
          } catch (error) {
            evt = window.document.createEvent("HTMLEvents");
            evt.initEvent("error", true, false);
            evt.error = error;
            return window.dispatchEvent(evt);
          } finally {
            delete timers[handle];
          }
        }, this)
      };
      handle = ++lastHandle;
      timers[handle] = timer;
      return handle;
    };
    window.setInterval = function(fn, delay) {
      var handle, timer;
      timer = {
        when: window.browser.clock + delay,
        interval: true,
        fire: __bind(function() {
          var evt;
          window.browser.log("Firing interval " + handle + ", interval: " + delay);
          try {
            return window._evaluate(fn);
          } catch (error) {
            evt = window.document.createEvent("HTMLEvents");
            evt.initEvent("error", true, false);
            evt.error = error;
            return window.dispatchEvent(evt);
          } finally {
            timer.when = window.browser.clock + delay;
          }
        }, this)
      };
      handle = ++lastHandle;
      timers[handle] = timer;
      return handle;
    };
    window.clearTimeout = function(handle) {
      var _ref;
      if ((_ref = timers[handle]) != null ? _ref.timeout : void 0) {
        return delete timers[handle];
      }
    };
    window.clearInterval = function(handle) {
      var _ref;
      if ((_ref = timers[handle]) != null ? _ref.interval : void 0) {
        return delete timers[handle];
      }
    };
    processing = 0;
    waiting = [];
    wakeUp = function() {
      var waiter, _results;
      if (--processing === 0) {
        _results = [];
        while (waiter = waiting.pop()) {
          _results.push(process.nextTick(waiter));
        }
        return _results;
      }
    };
    this.perform = function(fn) {
      ++processing;
      fn(wakeUp);
    };
    this.wait = function(window, terminate, callback, intervals) {
      return process.nextTick(__bind(function() {
        var done, earliest, event, handle, timer;
        earliest = null;
        for (handle in timers) {
          timer = timers[handle];
          if (timer.interval && intervals === false) {
            continue;
          }
          if (!earliest || timer.when < earliest.when) {
            earliest = timer;
          }
        }
        if (earliest) {
          intervals = false;
          event = function() {
            if (window.browser.clock < earliest.when) {
              window.browser.clock = earliest.when;
            }
            return earliest.fire();
          };
        }
        if (event) {
          try {
            event();
            done = false;
            if (typeof terminate === "number") {
              --terminate;
              if (terminate <= 0) {
                done = true;
              }
            } else if (typeof terminate === "function") {
              if (terminate.call(window) === false) {
                done = true;
              }
            }
            if (done) {
              return process.nextTick(function() {
                window.browser.emit("done", window.browser);
                if (callback) {
                  return callback(null, window);
                }
              });
            } else {
              return this.wait(window, terminate, callback, intervals);
            }
          } catch (err) {
            window.browser.emit("error", err);
            if (callback) {
              return callback(err, window);
            }
          }
        } else if (processing > 0) {
          return waiting.push(__bind(function() {
            return this.wait(window, terminate, callback, intervals);
          }, this));
        } else {
          window.browser.emit("done", window.browser);
          if (callback) {
            return callback(null, window);
          }
        }
      }, this));
    };
    this.dump = function() {
      return ["The time:   " + window.browser.clock, "Timers:     " + (Object.keys(timers).length), "Processing: " + processing, "Waiting:    " + waiting.length];
    };
  }
  return EventLoop;
})();
exports.EventLoop = EventLoop;